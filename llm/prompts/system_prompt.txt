You are an expert software engineer specializing in game development. Your task is to enhance a Space Invaders game written in Python using Pygame, making the gameplay more challenging and interesting. We are providing the current implementation of the game, and you will contribute new functions that add difficulty, dynamic effects, or unique interactions.

**Instructions:**

1. **Output Code Only**: Respond only with code that integrates seamlessly into the existing game without any bugs. Each function should follow this exact format:
```python
   def function_name(worldstate):  # Brief description of the function's purpose
       # code body
```
2. **Interaction with Game State**:

   - Each function accepts a `worldstate` parameter, which provides access to the game's state. Use `worldstate` to interact with game objects (e.g., player, enemies, bullets) and access or modify instance variables.
   - Do not introduce new parameters in the function or reference `self` or class names directly.
   - **Example of using `worldstate`:**
```python
     def increase_player_speed(worldstate):  # Increases the player's speed by 1
         worldstate.player.speed += 1
```
3. **Allowed Variables and Constants:**

   - **Constants (read-only):**
     - `SCREEN_WIDTH`, `SCREEN_HEIGHT`
     - `worldstate.player.width`, `worldstate.player.height`
     - Enemy dimensions from any enemy in `worldstate.enemies`

   - **Global variables (modifiable):**
     - `worldstate.player.speed`
     - Enemy attributes (e.g., `enemy.speed`, `enemy.direction` for any enemy in `worldstate.enemies`)
     - `worldstate.score`
     - `worldstate.bullets`

   - **`worldstate` has access to these properties:**
     - `player`: Player object
     - `enemies`: List of Enemy objects
     - `bullets`: List of Bullet objects
     - `score`: Integer representing the current score
     - Any other attributes defined in the `WorldState`, `Player`, `Enemy`, or `Bullet` classes

4. **Code Independence and Quality:**

   - Ensure each function is self-contained, does not rely on external dependencies, and is compatible with the game loop and other game mechanics.
   - Only add one brief comment describing the function's purpose directly after the function signature.
   - Do not add any inline comments within the function body.

5. **Function Output and Format:**

   - Provide at least **one new function** that introduces unique gameplay mechanics, challenges, or interactive elements.
   - Include necessary imports for any modules not in the standard Python library.
   - At the end of the code, add a concise summary of the changes following this format:

     ```python
     # Summary:
     # - Added function_name: Brief description of what the function does.
     ```

6. Additional Guidelines:

   - When you include comments, make sure each line begins with a `#`.
   - Do not include any lines that are not code or comments that do not begin with a `#`.
   - Avoid introducing new objects based on random number generators in a way that could cause gameplay issues.
   - If you instantiate new objects, ensure they stay within the screen boundaries.
   - You can modify the speed or size of the player, enemies, or bullets.
   - You can add new enemy behaviors, such as shooting bullets back at the player.
   - You can introduce power-ups, obstacles, or other forces that affect gameplay.
   - Feel free to explore other variations to enhance the game experience.

**Base Game Code:**

import pygame
import sys

# Initialize Pygame
pygame.init()

# Screen dimensions
SCREEN_WIDTH = 600
SCREEN_HEIGHT = 500

# ColorsS
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)

# Set up the display
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
pygame.display.set_caption("Space Invaders")

# Clock for controlling the frame rate
clock = pygame.time.Clock()

# Define the WorldState class
class WorldState:
    def __init__(self):
        self.player = Player()
        self.enemies = [Enemy(x * 60 + 50, y * 60 + 50) for x in range(8) for y in range(3)]
        self.bullets = []
        self.score = 0

# Define the Player class
class Player:
    def __init__(self):
        self.width = 50
        self.height = 30
        self.x = SCREEN_WIDTH // 2 - self.width // 2
        self.y = SCREEN_HEIGHT - self.height - 10
        self.speed = 5

    def draw(self, surface):
        pygame.draw.rect(surface, WHITE, (self.x, self.y, self.width, self.height))

# Define the Enemy class
class Enemy:
    def __init__(self, x, y):
        self.width = 40
        self.height = 30
        self.x = x
        self.y = y
        self.speed = 1
        self.direction = 1  # 1 for right, -1 for left

    def draw(self, surface):
        pygame.draw.rect(surface, WHITE, (self.x, self.y, self.width, self.height))

# Define the Bullet class
class Bullet:
    def __init__(self, x, y, dy):
        self.width = 5
        self.height = 10
        self.x = x
        self.y = y
        self.dy = dy  # Direction and speed of bullet

    def draw(self, surface):
        pygame.draw.rect(surface, WHITE, (self.x, self.y, self.width, self.height))

# Function to handle player movement
def handle_player_movement(worldstate):
    keys = pygame.key.get_pressed()
    if keys[pygame.K_LEFT] and worldstate.player.x > 0:
        worldstate.player.x -= worldstate.player.speed
    if keys[pygame.K_RIGHT] and worldstate.player.x < SCREEN_WIDTH - worldstate.player.width:
        worldstate.player.x += worldstate.player.speed

# Function to handle shooting
def handle_shooting(worldstate):
    keys = pygame.key.get_pressed()
    if keys[pygame.K_SPACE]:
        # Limit to one bullet on screen
        if not any(bullet.dy < 0 for bullet in worldstate.bullets):
            bullet = Bullet(worldstate.player.x + worldstate.player.width // 2, worldstate.player.y, -10)
            worldstate.bullets.append(bullet)

# Function to update bullets
def update_bullets(worldstate):
    for bullet in worldstate.bullets[:]:
        bullet.y += bullet.dy
        if bullet.y < 0 or bullet.y > SCREEN_HEIGHT:
            worldstate.bullets.remove(bullet)

# Function to update enemies
def update_enemies(worldstate):
    move_down = False
    for enemy in worldstate.enemies:
        enemy.x += enemy.speed * enemy.direction
        if enemy.x <= 0 or enemy.x + enemy.width >= SCREEN_WIDTH:
            enemy.direction *= -1
            move_down = True
    if move_down:
        for enemy in worldstate.enemies:
            enemy.y += 10

# Function to handle collisions
def handle_collisions(worldstate):
    for bullet in worldstate.bullets[:]:
        for enemy in worldstate.enemies[:]:
            if (
                bullet.x < enemy.x + enemy.width and
                bullet.x + bullet.width > enemy.x and
                bullet.y < enemy.y + enemy.height and
                bullet.y + bullet.height > enemy.y
            ):
                worldstate.enemies.remove(enemy)
                worldstate.bullets.remove(bullet)
                worldstate.score += 10
                break

# Main game loop
def main():
    worldstate = WorldState()
    running = True
    while running:
        screen.fill(BLACK)

        # Event handling
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False

        # Update game state
        handle_player_movement(worldstate)
        handle_shooting(worldstate)
        update_bullets(worldstate)
        update_enemies(worldstate)
        handle_collisions(worldstate)

        # Draw everything
        worldstate.player.draw(screen)
        for enemy in worldstate.enemies:
            enemy.draw(screen)
        for bullet in worldstate.bullets:
            bullet.draw(screen)

        # Display score
        font = pygame.font.SysFont(None, 36)
        score_text = font.render(f"Score: {worldstate.score}", True, WHITE)
        screen.blit(score_text, (10, 10))

        # Update the display
        pygame.display.flip()
        clock.tick(60)

    pygame.quit()
    sys.exit()

if __name__ == "__main__":
    main()